```
auto p1 = std::make_pair(n, n);
```

pair 无法直接用 unordered_map 由于哈希函数没有指定的原因.

可以通过添加一些界外元素来避免边界的判断，例如链表最前面加一个dummy node, 或者有序的数组左边加上 int_min， 后面加上 int_max.

还是需要再熟悉一下二分查找。

对于有些情况， 可能从1开始索引会更简单一些。

对于一些输入对称的题目，我们可以假设其中一个大或者小，然后再最开始的时候通过交换让我们期望大或者小的，确实是满足条件的。

stock 问题都可以用状态机来解决。

[Share my DP solution (By State Machine Thinking) - LeetCode Discuss](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/discuss/75928/Share-my-DP-solution-(By-State-Machine-Thinking))

[Dynamic Programming State Machine Fundamentals - TheAlgorists](https://www.thealgorists.com/Algo/DynamicProgramming/StateMachineConcept/Fundamentals)

对于for 循环遍历的时候， 要注意索引是否有可能小于0， 否则用 `size_t` 是一件很危险的事情。

[LeetcodeTop/backend.md at master · afatcoder/LeetcodeTop · GitHub](https://github.com/afatcoder/LeetcodeTop/blob/master/bytedance/backend.md)

我们对于一些问题，记得有 priority_queue 这种比较犯规的现成的数据结构，一些小顶堆，大顶堆都可以用这个轻松解决。默认从大到小。他的构造函数等。
![[Pasted image 20210114062658.png]]

```
class Solution {
public:
    struct CustomCompare
    {
        bool operator()(const int& lhs, const int& rhs)
        {
            return lhs > rhs;
        }
    };
    
    int findKthLargest(vector<int>& nums, int k) {
        priority_queue<int, std::vector<int>, CustomCompare> p;
        for (size_t i = 0; i < nums.size(); i++)
        {
            p.push(nums[i]);
            if (p.size() > k)
            {
                p.pop();
            }
        }

        return p.top();
    }
};
```

让 `p` 里的结果从小到大排列，也就是 return true的元素可以接到后面，而不是放到前面。

并查集的问题似乎现在总会忽略一些边缘情况， 就是可以写出来，但是写出来的不对。因为是完全凭着自己的想象写的，[并查集 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/ds/dsu/) 详细讲解。连续性的相似或者相近都可以变成并查集的问题。

并查集是一种树形的数据结构，顾名思义，它用于处理一些不交集的 **合并** 及 **查询** 问题。 它支持两种操作：

-   查找（Find）：确定某个元素处于哪个子集；
-   合并（Union）：将两个子集合并成一个集合


```
class UnionFind {
public:
    UnionFind(size_t p_sz)
		: m_uf(p_sz), 
		  m_sizes(p_sz, 1),
		  m_connected_components(p_sz)
    {
        for (int i = 0; i < m_uf.size(); ++i) 
		{
            m_uf[i] = i;
        }
    }
    
    int ConnectedComponents() 
	{
        return m_connected_components;
    }
    
    void Union(int i, int j) 
	{
        int parent_i = Find(i);
        int parent_j = Find(j);
        if (parent_i == parent_j) 
		{
            return;
        }
        
        if (m_sizes[i] < m_sizes[j]) 
		{
            m_sizes[j] += m_sizes[i];
            m_uf[parent_i] = parent_j;
        }
		else
		{
            m_sizes[i] += m_sizes[j];
            m_uf[parent_j] = parent_i;
        }
        
        --m_connected_components;
    }
    
private:
    
    int Find(int i) 
	{   
        int parent = i;
        while (m_uf[parent] != parent) 
		{
            parent = m_uf[parent];
        }
        
        // Path compression
		// 把所有连接的变成 false
        while (m_uf[i] != parent)
		{
            int next = m_uf[i];
            m_uf[i] = parent;
            i = next;
        }
        
        return parent;
    }
    
    vector<int> m_uf; // 
    int m_connected_components;
    vector<int> m_sizes; // 启发式合并，表示该集合的代价等，用代价较小的来合并。
};
```

如果对并查集不做优化的话， code是下面的

```
class UnionFind {
    private:
        unordered_map<string, string> connection;
    public:
        void unions(string x, string y) {
            if(connection.count(x) == 0) {  // Creating x email if it is not present in the pool
                connection[x] = x;
            }
            if(connection.count(y) == 0) {  // Creating x email if it is not present in the pool
                connection[y] = y;
            }

            string par_x = find(x), par_y = find(y);
            connection[par_x] = par_y;  // Union operation
        }
    
        string find(string x) { // Finds the representative for email
            if(connection[x] != x)
                connection[x] = find(connection[x]);
            return connection[x];
        }
        
        bool isRepresentative(string s) {   // Returns true if it is the representative of the group
            return connection[s] == s;
        }
        
        vector<string> getGroupEmails(string remail) {  // Returns all the emails which has remail as representative
            vector<string> eList;
            for(auto email: connection)
                if(find(email.first) == remail) eList.push_back(email.first);
            return eList;
        }
};
```

明天专注做并查集的题目！！！

基本的链表反转等操作实现还是有些复杂。找到最优的方法，并固化。
```
ListNode* reverse(ListNode* head) {
	ListNode* pre = NULL, *cur = head, *tmp = NULL;
	while(cur){
		tmp = cur->next;
		cur->next = pre;
		pre = cur;
		cur = tmp;
	}
	return pre;
}
```


| 百度 | 后端 | 268. 缺失数字                    | https://leetcode.com/problems/missing-number/                                                    | 2  |

一个简单题目,但是用了个很复杂的解法,存在很简单的解法.